---
title: 内存泄漏的场景及检测
date: 2018-11-30 09:27:15
tags:
categories:
- 内存检测
---
#### 什么是内存泄露
当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。

#### 内存泄露的常见场景
**非静态内部类，静态实例化**

```
/**
 * 自定义实现的Activity
 */
public class MyActivity extends AppCompatActivity {

    /**
     * 静态成员变量
     */
    public static InnerClass innerClass = null;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_my);

        innerClass = new InnerClass();
    }

    class InnerClass {

        public void doSomeThing() {
        }
    }
}
```

这里内部类InnerClass隐式的持有外部类MyActivity的引用，而在MyActivity的onCreate方法中调用了

```
innerClass = new InnerClass();
```

这样innerClass就会在MyActivity创建的时候是有了他的引用，而innerClass是静态类型的不会被垃圾回收，MyActivity在执行onDestory方法的时候由于被innerClass持有了引用而无法被回收，所以这样MyActivity就总是被innerClass持有而无法回收造成内存泄露。

**不正确的使用Context对象造成内存泄露**

```
/**
 * 自定义单例对象
 */
public class Single {
    private static Single instance;
    private Context context;
    private Object obj = new Object();

    private Single(Context context) {
        this.context = context;
    }

    /**
     * 初始化获取单例对象
     */
    public static Single getInstance(Context context) {
        if (instance == null) {
            synchronized(obj) {
                if (instance == null) {
                    instance = new Single(context);
                }
            }
        }
        return instance;
    }
}
```

我们通过懒汉模式创建单例对象，并且在创建的时候需要传入一个Context对象，而这时候如果我们使用Activity、Service等Context对象，由于单例对象的生命周期与进程的生命周期相同，会造成我们传入的Activity、Service对象无法被回收，这时候就需要我们传入Application对象，或者在方法中使用Application对象，上面的代码可以改成：

```
/**
 * 自定义单例对象
 */
public class Single {
    private static Single instance;
    private Context context;
    private Object obj = new Object();

    private Single(Context context) {
        this.context = context;
    }

    /**
     * 初始化获取单例对象
     */
    public static Single getInstance(Context context) {
        if (instance == null) {
            synchronized(obj) {
                if (instance == null) {
                    instance = new Single(context.getApplication());
                }
            }
        }
        return instance;
    }
}
```

这样就不会有内存泄露的问题了。

**使用Handler异步消息通信**

```
/**
 * 定义Handler成员变量
 */
Handler handler = new Handler() {  
        @Override  
        public void handleMessage(Message msg) {  
            dosomething();  

        }  
    };  
```

但是这样也存在着一个隐藏的问题：在Activity中使用Handler创建匿名内部类会隐式的持有外部Activity对象的引用，当子线程使用Handler暂时无法完成异步任务时，handler对象无法销毁，同时由于隐式的持有activity对象的引用，造成activity对象以及相关的组件与资源文件同样无法销毁，造成内存泄露。 
改为静态内部类，并软引用持有context.

**使用资源文件结束之后未关闭**
在使用一些资源性对象比如(Cursor，File，Stream，ContentProvider等)往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于Java虚拟机内，还存在于Java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄露。

因为有些资源性对象，比如SQLiteCursor(在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭)，如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该立即调用它的close()函数，将其关闭掉，然后再置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。

```
/**
 * 初始化Cursor对象
 */
Cursor cursor = getContentResolver().query(uri...); 
if (cursor.moveToNext()) { 
    /**
     * 执行自设你的业务代码
     */ 
     doSomeThing();
}
```

这时候我们应当在doSomeThing之后执行cursor的close方法，关闭资源对象。

```
/**
 * 初始化Cursor对象
 */
Cursor cursor = getContentResolver().query(uri...); 
if (cursor.moveToNext()) { 
    /**
     * 执行自设你的业务代码
     */ 
     doSomeThing();
}

if (cursor != null) {
    cursor.close();
}
```

**Bitmap使用不当**
bitmap对象使用的内存较大，当我们不再使用Bitmap对象的时候一定要执行recycler方法，这里需要指出的是当我们在代码中执行recycler方法，Bitmap并不会被立即释放掉，其只是通知虚拟机该Bitmap可以被recycler了。

当然了现在项目中使用的一些图片库已经帮我们对图片资源做了很好的优化缓存工作，是我们省去了这些操作。

**一些框架使用了注册方法而未反注册**
比如我们时常使用的事件总线框架-EventBus，当我们需要注册某个Activity时需要在onCreate中：

```
EventBus.getDefault().register(this);
```

然后这样之后就没有其他操作的话就会出现内存泄露的情况，因为EventBus对象会是有该Activity的引用，即使执行了改Activity的onDestory方法，由于被EventBus隐式的持有了该对象的引用，造成其无法被回收，这时候我们需要在onDestory方法中执行

```
EventBus.getDefault().unregister(this);
```

**集合中的一些方法的错误使用**
（1）比如List列表静态化，只是添加元素而不再使用时不清楚元素； 
（2）map对象只是put，而无remove操作等等；

#### 关于内存泄露检测的开源方案
LeakCanary 

#### 关于屏蔽内存泄露的建议
1、正确的保证内存对象的生命周期，就是尽量保证内存对象在其生命周期内创建于结束，比如Android中的“上帝对象Context”，要保证不同的场景下使用不同的Context对象，下面是一张Context对象的使用场景图： 

![avatar](https://github.com/zhoulzhou/MarkDownPhotos/raw/master/android/nei1.png)

2、对资源对象的使用要在使用完成之后保证调用其资源的关闭方法，而非仅仅是对资源引用的关闭操作；

3、静态化资源对象其生命周期就会变成与进程的生命周期相同，在使用静态化时一定要考虑清楚该对象静态化是否存在内存泄露的可能；

4、对Android开发中常见的内存泄露场景要做到了然于胸，了解一些Android中常见的内存泄露检测方法；

#### 分析内存的技巧
您应对应用代码施加压力并尝试强制内存泄漏。 在应用中引发内存泄漏的一种方式是，先让其运行一段时间，然后再检查堆。 泄漏在堆中可能逐渐汇聚到分配顶部。 不过，泄漏越小，您越需要运行更长时间的应用才能看到泄漏。
**您还可以通过以下方式之一触发内存泄漏：**

1、将设备从纵向旋转为横向，然后在不同的 Activity 状态下反复操作多次。 旋转设备经常会导致应用泄漏 Activity、Context 或 View 对象，因为系统会重新创建 Activity，而如果您的应用在其他地方保持对这些对象之一的引用，系统将无法对其进行垃圾回收。
2、处于不同的 Activity 状态时，在您的应用与另一个应用之间切换（导航到主屏幕，然后返回到您的应用）。

#### 总结

关于内存泄露其实主要记住一个原则就好：确保对象能够在正确的时机被回收掉。然后我们根据具体内存泄露的场景具体解决就好了。