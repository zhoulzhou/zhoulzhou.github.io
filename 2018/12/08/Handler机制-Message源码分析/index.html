<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Message 源码分析本文出现的源码版本均为Android 7.1.1(Nougat) - API 25 版本。 Message作为消息传递的载体，源码主要分为以下几个部分： 1、操作数据相关，类似getter()和setter()这种方法还有之前提到过的what和obj这类属性。2、创建与回收对象实例相关，除了用关键字new外，其他得到对象实例的方法。3、其他工具类性质的扩展方法。 Messa">
<meta name="keywords" content="handler,message">
<meta property="og:type" content="article">
<meta property="og:title" content="Handler机制-Message源码分析">
<meta property="og:url" content="https://weiteluwei.com/2018/12/08/Handler机制-Message源码分析/index.html">
<meta property="og:site_name" content="KEEM--BLOG">
<meta property="og:description" content="Message 源码分析本文出现的源码版本均为Android 7.1.1(Nougat) - API 25 版本。 Message作为消息传递的载体，源码主要分为以下几个部分： 1、操作数据相关，类似getter()和setter()这种方法还有之前提到过的what和obj这类属性。2、创建与回收对象实例相关，除了用关键字new外，其他得到对象实例的方法。3、其他工具类性质的扩展方法。 Messa">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://weiteluwei.com/2018/12/08/Handler机制-Message源码分析/mes.webp">
<meta property="og:image" content="https://weiteluwei.com/2018/12/08/Handler机制-Message源码分析/mes1.webp">
<meta property="og:image" content="https://weiteluwei.com/2018/12/08/Handler机制-Message源码分析/mes2.webp">
<meta property="og:image" content="https://weiteluwei.com/2018/12/08/Handler机制-Message源码分析/mes6.webp">
<meta property="og:updated_time" content="2018-12-08T14:46:54.890Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Handler机制-Message源码分析">
<meta name="twitter:description" content="Message 源码分析本文出现的源码版本均为Android 7.1.1(Nougat) - API 25 版本。 Message作为消息传递的载体，源码主要分为以下几个部分： 1、操作数据相关，类似getter()和setter()这种方法还有之前提到过的what和obj这类属性。2、创建与回收对象实例相关，除了用关键字new外，其他得到对象实例的方法。3、其他工具类性质的扩展方法。 Messa">
<meta name="twitter:image" content="https://weiteluwei.com/2018/12/08/Handler机制-Message源码分析/mes.webp">






  <link rel="canonical" href="https://weiteluwei.com/2018/12/08/Handler机制-Message源码分析/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Handler机制-Message源码分析 | KEEM--BLOG</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">KEEM--BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://weiteluwei.com/2018/12/08/Handler机制-Message源码分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Keem Wang">
      <meta itemprop="description" content="Stay hungry Stay foolish">
      <meta itemprop="image" content="/images/avatarx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KEEM--BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Handler机制-Message源码分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-08 15:42:08 / 修改时间：22:46:54" itemprop="dateCreated datePublished" datetime="2018-12-08T15:42:08+08:00">2018-12-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/Handler机制/" itemprop="url" rel="index"><span itemprop="name">Handler机制</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="Message-源码分析"><a href="#Message-源码分析" class="headerlink" title="Message 源码分析"></a>Message 源码分析</h4><p>本文出现的源码版本均为Android 7.1.1(Nougat) - API 25 版本。</p>
<p>Message作为消息传递的载体，源码主要分为以下几个部分：</p>
<p>1、操作数据相关，类似getter()和setter()这种方法还有之前提到过的what和obj这类属性。<br>2、创建与回收对象实例相关，除了用关键字new外，其他得到对象实例的方法。<br>3、其他工具类性质的扩展方法。</p>
<h4 id="Message中的数据属性与方法"><a href="#Message中的数据属性与方法" class="headerlink" title="Message中的数据属性与方法"></a>Message中的数据属性与方法</h4><p>首先说一个本篇文章忽略的属性及相关方法：public Messenger replyTo;。<br>为什么要忽略过去呢？因为Messenger类是基于Message上实现进程间通信的类。注意，是进程间通信，不是线程间通信。一方面进程间通信不是本文分析的重点，另一方面进程间通信需要掌握AIDL方面的知识。<br>接下来就让我们看看Message源码有哪些可供我们使用的属性吧：</p>
<blockquote>
<p>public int what;：开发者可自定义的消息标识代码，用于区分不同的消息。<br>public int arg1;：如果要传递的消息只有少量的integer型数据，可以使用这个属性。<br>public int arg2;：同上面arg1。<br>public Object obj;开发者可自定义类型的传输数据。</p>
</blockquote>
<p>上面四个属性作为常用的消息传递的数据载体可直接赋值，例如msg.arg1 = 100;。基本可以满足我们日常开发中简单消息传递。</p>
<p>如果上面几个数据属性不能满足我们的需求，可以使用扩展数据：Bundle来传递（Bundle是啥应该都知道吧？）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Bundle data;</span><br><span class="line"></span><br><span class="line">    // 得到Bundle数据，如果data是空的就new一个</span><br><span class="line">    public Bundle getData() &#123;</span><br><span class="line">        if (data == null) &#123;</span><br><span class="line">            data = new Bundle();</span><br><span class="line">        &#125;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 得到Bundle数据，如果data是空的就返回 null</span><br><span class="line">    public Bundle peekData() &#123;</span><br><span class="line">        return data;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置Bundle数据</span><br><span class="line">    public void setData(Bundle data) &#123;</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码也没什么逻辑好分析的，值得一提就是Bundle data不是public的，所以我们不能直接操作这个属性，需要通过上面三个方法操作数据。使用Bundle数据也非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle = new Bundle();</span><br><span class="line">    bundle.putString(&quot;String&quot;,&quot;value&quot;);</span><br><span class="line">    bundle.putFloat(&quot;float&quot;,0.1f);</span><br><span class="line">        </span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.setData(bundle);</span><br></pre></td></tr></table></figure>
<h4 id="创建与回收Message对象的基本方法"><a href="#创建与回收Message对象的基本方法" class="headerlink" title="创建与回收Message对象的基本方法"></a>创建与回收Message对象的基本方法</h4><p>先看一下源码中Meesage的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/** Constructor (but the preferred way </span><br><span class="line">        to get a Message is to call &#123;@link #obtain() Message.obtain()&#125;).</span><br><span class="line">    */</span><br><span class="line">    public Message() &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>没错，这货的构造方法里什么也没有，不过它的注释却告诉我们想要得到Message对象首选的方法应该是调用静态方法Message.obtain()。那这个obtain()方法干了什么呢？其实就是<strong>内部维持了一个链表形式的Meesage对象缓存池，</strong>这样会节省重复实例化对象产生的开销成本。<br>老样子还是理论分析一波，数据结构中的链表一个单元有两个值，当前单元的值（head）和下一个单元的地址指针（next），如果下一个单元不存在那么next就是null的。</p>
<img src="/2018/12/08/Handler机制-Message源码分析/mes.webp">
<p>所以，想要实现Message对象链表式缓存池就需要额外的两个Message类型的引用head和next，都说了叫缓存池，所以把head叫pool更合适一点。<br>有了链表的基础结构我们再想实例化对象的时候就可以先去链表缓存池中看看有没有，有的话直接从缓存池中拿出来用，没有再new一个。</p>
<img src="/2018/12/08/Handler机制-Message源码分析/mes1.webp">
<p>由于代码多起来逻辑有些复杂，这样不太好分析，所以我在源码中加了许多自己的注释，下面代码看上去很长，其实把注释都去掉后并没有多少。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 用于标识当前对象是否存在于缓存池，0代表不在缓存池中</span><br><span class="line">    int flags;</span><br><span class="line"></span><br><span class="line">    /** </span><br><span class="line">     * 这个常量是供上面的 flags 使用的，它表示in use（正在使用）状态</span><br><span class="line">     *</span><br><span class="line">     * 如果Message对象被存入了MessageQueue消息队列排队等待Looper处</span><br><span class="line">     * 理或者被回收到缓存池中等待重复利用时，那么它就是in use（正在使用）状态</span><br><span class="line">     * </span><br><span class="line">     * 只有在new Message()和Message.obtain()时候才可以清除掉flags上的in use状态</span><br><span class="line">     *</span><br><span class="line">     * 你不可以让一个in use状态的Message对象去传递消息。</span><br><span class="line">     *</span><br><span class="line">     *  1&lt;&lt; 0 还是1，真不知道为啥要这么写，直接写等于1不就得了</span><br><span class="line">     */</span><br><span class="line">    static final int FLAG_IN_USE = 1 &lt;&lt; 0;</span><br><span class="line"></span><br><span class="line">    /** 静态常量对象，通过synchronized (sPoolSync)让它作为线程并发操作时的锁</span><br><span class="line">     * 确保同一时刻只有一个线程可以访问当前对象的引用</span><br><span class="line">     */</span><br><span class="line">    private static final Object sPoolSync = new Object();</span><br><span class="line">    </span><br><span class="line">    // 当前链表缓存池的入口，装载着缓存池中第一个可用的对象</span><br><span class="line">    private static Message sPool;</span><br><span class="line"></span><br><span class="line">    // 链表缓存池中指向下一个对象引用的next指针</span><br><span class="line">    Message next;</span><br><span class="line">    </span><br><span class="line">    // 当前链表缓存池中对象的数量</span><br><span class="line">    private static int sPoolSize = 0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从缓存池中拿出来一个Message对象给你</span><br><span class="line">     * 可以让我们在许多情况下避免分配新对象。</span><br><span class="line">     */</span><br><span class="line">    public static Message obtain() &#123;</span><br><span class="line">        // 上锁，这期间只有一个线程可以执行这段代码</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            // pool不等于空就说明缓存池中还有可用的对象，直接取出来</span><br><span class="line">            if (sPool != null) &#123;</span><br><span class="line">                // 声明一个Message引用指向缓存池中的pool对象</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                // 让缓存池中pool引用指向它的next引用的对象</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                // 因为该对象已经从缓存池中被取出，所以将next指针置空</span><br><span class="line">                m.next = null;</span><br><span class="line">                // 将从缓存池中取出的对象的flags的in use标识清除掉</span><br><span class="line">                m.flags = 0; </span><br><span class="line">                // 缓存池中Message对象数量减去一个</span><br><span class="line">                sPoolSize--;</span><br><span class="line">                return m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果缓存池中没有可用的对象就new一个吧</span><br><span class="line">        return new Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>理论上我们希望sPool引用指向了链表缓存池中的第一个对象，让它作为整个缓存池的出入口。所以我们把它设置成static的，这样它就与实例化出来的对象无关，也就是说无论我们在哪个Message对象中进行操作，sPool还是sPool。</p>
<h4 id="静态方法obtain-的代码逻辑流程："><a href="#静态方法obtain-的代码逻辑流程：" class="headerlink" title="静态方法obtain()的代码逻辑流程："></a>静态方法obtain()的代码逻辑流程：</h4><p>先判断缓存池是不是空的：if(sPool != null),如果是空的就直接：return new Message();，不是空的就声明一个引用让它指向缓存池第一个对象：Message m = sPool;，而缓存池的链表头部sPool引用就指向了链表中下一个对象：sPool = m.next;，因为这个时候缓存池中第一个对象已经取出交给了引用Message m，所以需要清除掉这个对象身上的特殊标识，包括缓存池中的next引用和用来标记对象状态的flags值：m.next = null; m.flags = 0;,最后将缓存池中的对象数量减一：sPoolSize–;。<br>逻辑理清了整个流程就显得很简单了，再看看图解逻辑流程：</p>
<img src="/2018/12/08/Handler机制-Message源码分析/mes2.webp">
<p>分析到这里我们知道了为什么官方推荐我们使用Message.obtain()得到对象了，因为它是在缓存池中取出来重复利用的，但是通过上面代码也看可以看到，只有缓存池里有东西时也就是sPool != null的时候才可以取，Message是怎么把对象回收到缓存池中的呢？</p>
<h4 id="回收Message对象到缓存池的方法"><a href="#回收Message对象到缓存池的方法" class="headerlink" title="回收Message对象到缓存池的方法"></a>回收Message对象到缓存池的方法</h4><p>阅读源码后发现有一个public void recycle()方法用于回收Message对象，但是它也牵扯出了一堆其他方法与属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// 缓存池最大存储值</span><br><span class="line">    private static final int MAX_POOL_SIZE = 50;</span><br><span class="line"></span><br><span class="line">    // 区分当前Android版本是否大于或者等于LOLLIPOP版本的全局静态变量，默认初始值为true</span><br><span class="line">    private static boolean gCheckRecycle = true;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  用于区分当前Android版本是否大于或者等于LOLLIPOP版本</span><br><span class="line">     *  内部隐藏方法，在APP启动时就会执行该方法，开发者是不可见的</span><br><span class="line">     *  @hide</span><br><span class="line">     */</span><br><span class="line">    public static void updateCheckRecycle(int targetSdkVersion) &#123;</span><br><span class="line">        if (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            gCheckRecycle = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断当前对象的flags是否为in-use状态</span><br><span class="line">     */</span><br><span class="line">    boolean isInUse() &#123;</span><br><span class="line">        return ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 调用这个方法后，当前对象就会被回收入缓存池中。</span><br><span class="line">     * 你不能回收一个在MessageQueue排队等待处理或者正在交付给Handler处理的Message对象</span><br><span class="line">     * 说白了就是in-use状态的不可回收</span><br><span class="line">     */</span><br><span class="line">    public void recycle() &#123;</span><br><span class="line">        // 判断当前对象是否为in-use状态</span><br><span class="line">        if (isInUse()) &#123;</span><br><span class="line">            // 如果当前版本大于或者等于LOLLIPOP则抛出异常</span><br><span class="line">            if (gCheckRecycle) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;</span><br><span class="line">                        + &quot;is still in use.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果当前版本小于LOLLIPOP什么也不干直接结束方法</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 回收Message对象</span><br><span class="line">        recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 回收一个可能是in use状态的Message对象</span><br><span class="line">     * 在MessageQueue和Looper内部处理排队Message时也会使用这个方法</span><br><span class="line">     */</span><br><span class="line">    void recycleUnchecked() &#123;</span><br><span class="line">        // 将当前Message对象置为in-use状态</span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line"></span><br><span class="line">        // 清除当前Message对象的所有数据属性</span><br><span class="line">        what = 0;</span><br><span class="line">        arg1 = 0;</span><br><span class="line">        arg2 = 0;</span><br><span class="line">        obj = null;</span><br><span class="line">        replyTo = null;</span><br><span class="line">        sendingUid = -1;</span><br><span class="line">        when = 0;</span><br><span class="line">        target = null;</span><br><span class="line">        callback = null;</span><br><span class="line">        data = null;</span><br><span class="line"></span><br><span class="line">        // 上锁</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            // 如果当前缓存池对象中的数量小于缓存池最大存储值（50）就存入缓存池中</span><br><span class="line">            if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                // 存入缓存池</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = this;</span><br><span class="line">                // 缓存池数量加1</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑很清晰，执行recycle()方法后先判断当前对象是否为in-use状态：if (isInUse())，如果是in-use状态的话当前Android版本是LOLLIPOP(5.0)版本之前直接结束程序，LOLLIPOP及之后版本抛出异常。如果当前对象不是in-use状态，那么就执行recycleUnchecked()方法先将它切换到in-use状态：flags = FLAG_IN_USE;，再把所有的数据属性全部清除，最后把对象存入缓存池链表中。</p>
<img src="/2018/12/08/Handler机制-Message源码分析/mes6.webp">
<p><strong>为什么要区分Android LOLLIPOP(5.0)前后版本？</strong><br>源码刚开始就有两个用于区分Android版本的全局属性和方法：</p>
<p>private static boolean gCheckRecycle = true;<br>public static void updateCheckRecycle(int targetSdkVersion)</p>
<p>通过查看源码发现Message类在LOLLIPOP版本进行了一次更新也就是我们现在看到的源码，在LOLLIPOP版本之前虽然recycle()方法的注释上同样警告了我们不能回收in-use对象，但是如果你坚持让in-use状态的对象调用recycle()的话也会也会被回收：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * Android LOLLIPOP版本源码</span><br><span class="line">     *</span><br><span class="line">     * Return a Message instance to the global pool.  You MUST NOT touch</span><br><span class="line">     * the Message after calling this function -- it has effectively been</span><br><span class="line">     * freed.</span><br><span class="line">     */</span><br><span class="line">    public void recycle() &#123;</span><br><span class="line">        // 清除数据</span><br><span class="line">        clearForRecycle();</span><br><span class="line">        // 存入缓存池</span><br><span class="line">        synchronized (sPoolSync) &#123;</span><br><span class="line">            if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = this;</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以在LOLLIPOP版本的时候Google进行了改进，强制要求不可以回收in-use状态的对象否则抛出异常，但是为了兼容之前的版本，所以新增加了个内部私有的区分Android版本的方法。</p>
<h4 id="我们需要手动回收吗"><a href="#我们需要手动回收吗" class="headerlink" title="我们需要手动回收吗"></a>我们需要手动回收吗</h4><p>现在我们知道了通过执行recycle()方法回收Message对象，但是如果要为每个Message对象都进行手动回收岂不是很麻烦？<br>庆幸的是开发人员也想到了这一点，从源码中可以看到其实最终真正执行回收操作的调用recycleUnchecked()方法，且注释中告诉我们MessageQueue和Looper内部也会调用该方法执行回收。<br>这里先说一个结论，MessageQueue和Looper内部分发处理消息时，当它们得知当前这个Message对象已经使用完毕后就会直接调用recycleUnchecked()方法将它回收掉，等分析到MessageQueue和Looper再具体讲这个地方。<br>所以，如果我们用实例化Message对象是放入Handler中去传消息的，那么我们就不需要手动回收，他们内部自己就回收了。如果我们使用的Message对象跟Handler，Looper，MessageQueue一点交互都没有，那我们就自己去回收。</p>
<h4 id="包含Handler参数的obtain-方法"><a href="#包含Handler参数的obtain-方法" class="headerlink" title="包含Handler参数的obtain()方法"></a>包含Handler参数的obtain()方法</h4><p>给Message内部装了一个Handler起了什么作用呢？首先，我们可以通过上面讲解我们可以得出以下已知的结论：</p>
<p>1、表面上看我们使用Handler发送消息后，消息直接传回到了Handler内部的handleMessage(Message msg)方法中。<br>2、实际上是先把消息传入了MessageQueue中，Looper再从MessageQueue依次取出消息分发给Handler。<br>3、Looper是线程独立的， Looper和MessageQueue是一对一的。</p>
<p>但是，你有没有想过Looper和Handler是不是一对一的？答案当然是否定的，MessageQueue只负责队列消息，Looper只负责取出消息分发。他们的功能很明确而且通用。<br>所以，无论当前线程有多少个Handler，同样都只有一个Lopper和一个MessageQueue。</p>
<p>一个线程存在多个Handler</p>
<p>既然每个线程只有一个Looper和MessageQueue的话那么Looper分发消息的时候要如何判断当前这个Message是哪个Handler的呢？所以开发人员就给Message内部配置了一个Handler属性，这样Looper分发消息时直接调用Messgae内部的Handler属性就能找到它对应的handleMessage(Message msg)接收消息的方法了。<br>源码很简单，就是在空参方法obtain()基础上加了个Handler属性，还有它的getter()和setter()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Handler target;</span><br><span class="line"></span><br><span class="line">    public static Message obtain(Handler h) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTarget(Handler target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Handler getTarget() &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="包含Runnable参数的obtain-方法"><a href="#包含Runnable参数的obtain-方法" class="headerlink" title="包含Runnable参数的obtain()方法"></a>包含Runnable参数的obtain()方法</h4><p>跟上面类似，该方法就是在上面基础加了个Runnable参数，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Runnable callback;</span><br><span class="line"></span><br><span class="line">    public static Message obtain(Handler h, Runnable callback) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.callback = callback;</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Runnable getCallback() &#123;</span><br><span class="line">        return callback;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个Runnable的作用是：在Looper分发消息时如果Runnable callback不是空的，那么就不调用Handler的handleMessage(Message msg)方法，直接运行这个Runnable callback。注意，这里的运行是已经回到了Handler被创建的线程上，也就是说Runnable会运行在Handler被创建的线程上。</p>
<p>更多包含参数的obtain()方法</p>
<p>下面这些带参的obtain()方法我相信不用介绍大家也都能看的懂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain(Handler h, int what) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Message obtain(Handler h, int what, Object obj) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        m.obj = obj;</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Message obtain(Handler h, int what, int arg1, int arg2) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        m.arg1 = arg1;</span><br><span class="line">        m.arg2 = arg2;</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Message obtain(Handler h, int what, </span><br><span class="line">            int arg1, int arg2, Object obj) &#123;</span><br><span class="line">        Message m = obtain();</span><br><span class="line">        m.target = h;</span><br><span class="line">        m.what = what;</span><br><span class="line">        m.arg1 = arg1;</span><br><span class="line">        m.arg2 = arg2;</span><br><span class="line">        m.obj = obj;</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h4><p><strong>特殊属性long when;</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long when;</span><br><span class="line"></span><br><span class="line">  public long getWhen() &#123;</span><br><span class="line">      return when;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>既然这个属性的名字都叫when了那肯定就是跟时间有关了。还记得Handler给我们提供的方法中有几个可以控制时间的方法吗？例如XXXAtTime()和XXXDelayed()，when这个属性就是就用存储当前这个Message应该被处理的时间。当我们讲Handler和MessageQueue时会在提到它。</p>
<h4 id="序列化对象"><a href="#序列化对象" class="headerlink" title="序列化对象"></a>序列化对象</h4><p>Message支持对象的序列化，就是可以把对象转为字节形式，可以保存到本地也可以用于网络传输。如果不了解这方面的知识建议先查阅相关文章。<br>为了实现对象序列化，我们需要实现Parcelable接口，实例化Parcelable.Creator接口，并重写describeContents()和writeToParcel()方法。先看源码，再讲他们都是干啥的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">// 实现Parcelable接口</span><br><span class="line">public final class Message implements Parcelable &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // 实例化Parcelable.Creator接口，完成Parcel对象转Message对象的操作</span><br><span class="line">    public static final Parcelable.Creator&lt;Message&gt; CREATOR</span><br><span class="line">            = new Parcelable.Creator&lt;Message&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        public Message createFromParcel(Parcel source) &#123;</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.readFromParcel(source);</span><br><span class="line">            return msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Message[] newArray(int size) &#123;</span><br><span class="line">            return new Message[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 序列化对象时的特殊种类对象描述，这里开发人员没有修改，就是默认的0</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 重写Parcelable接口的writeToParcel方法，将Message对象转为Parcel对象，</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">       </span><br><span class="line">         // 以下代码均是将Message对象中的属性写入Parcel对象中</span><br><span class="line"></span><br><span class="line">        if (callback != null) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Can&apos;t marshal callbacks across processes.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.writeInt(what);</span><br><span class="line">        dest.writeInt(arg1);</span><br><span class="line">        dest.writeInt(arg2);</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Parcelable p = (Parcelable)obj;</span><br><span class="line">                dest.writeInt(1);</span><br><span class="line">                dest.writeParcelable(p, flags);</span><br><span class="line">            &#125; catch (ClassCastException e) &#123;</span><br><span class="line">                throw new RuntimeException(</span><br><span class="line">                    &quot;Can&apos;t marshal non-Parcelable objects across processes.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dest.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.writeLong(when);</span><br><span class="line">        dest.writeBundle(data);</span><br><span class="line">        Messenger.writeMessengerOrNullToParcel(replyTo, dest);</span><br><span class="line">        dest.writeInt(sendingUid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 从Parcel对象中读取数据转为当前对象的属性</span><br><span class="line">    private void readFromParcel(Parcel source) &#123;</span><br><span class="line">        what = source.readInt();</span><br><span class="line">        arg1 = source.readInt();</span><br><span class="line">        arg2 = source.readInt();</span><br><span class="line">        if (source.readInt() != 0) &#123;</span><br><span class="line">            obj = source.readParcelable(getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        when = source.readLong();</span><br><span class="line">        data = source.readBundle();</span><br><span class="line">        replyTo = Messenger.readMessengerOrNullFromParcel(source);</span><br><span class="line">        sendingUid = source.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码看上去很长，其实很简单，就是实现了Parcelable接口，接着重写将Message对象转为Parcel对象的方法writeToParcel()，再重写了接口Parcelable.Creator<t>完成Parcel对象转Message对象的方法。<br>这里用到的主要都是序列化对象Parcelable接口相关的知识。</t></p>
<h4 id="设置Message是异步传输还是同步传输"><a href="#设置Message是异步传输还是同步传输" class="headerlink" title="设置Message是异步传输还是同步传输"></a>设置Message是异步传输还是同步传输</h4><p>正常情况下，我们的消息其实是同步处理的，为什么这么说呢？<br>Looper的工作就是把消息队列MessageQueue中的消息依次取出然后分发，每个消息传输都是有时间顺序的，这个动作都是可控制的。<br>然而，将消息设置成异步传输后那么Message对象将不再受Looper的控制，传输的顺序可能会被打断，不一定哪个消息先传过来。<br>所以，请谨慎使用异步传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 该常量代表为异步传输方式</span><br><span class="line">    static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1;</span><br><span class="line"></span><br><span class="line">    // 判断是否为异步传输</span><br><span class="line">    public boolean isAsynchronous() &#123;</span><br><span class="line">        return (flags &amp; FLAG_ASYNCHRONOUS) != 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置当前对象是否为异步传输</span><br><span class="line">    public void setAsynchronous(boolean async) &#123;</span><br><span class="line">        if (async) &#123;</span><br><span class="line">            flags |= FLAG_ASYNCHRONOUS;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，用于标记是否为异步传输的标识跟用于判断是否为in-use状态的标识是共用的一个属性flags。</p>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/handler/" rel="tag"># handler</a>
          
            <a href="/tags/message/" rel="tag"># message</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/08/Handler机制-为何要有handler/" rel="next" title="Handler机制-为何要有handler">
                <i class="fa fa-chevron-left"></i> Handler机制-为何要有handler
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatarx.jpg" alt="Keem Wang">
            
              <p class="site-author-name" itemprop="name">Keem Wang</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry Stay foolish</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">55</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Message-源码分析"><span class="nav-number">1.</span> <span class="nav-text">Message 源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Message中的数据属性与方法"><span class="nav-number">2.</span> <span class="nav-text">Message中的数据属性与方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建与回收Message对象的基本方法"><span class="nav-number">3.</span> <span class="nav-text">创建与回收Message对象的基本方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法obtain-的代码逻辑流程："><span class="nav-number">4.</span> <span class="nav-text">静态方法obtain()的代码逻辑流程：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回收Message对象到缓存池的方法"><span class="nav-number">5.</span> <span class="nav-text">回收Message对象到缓存池的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#我们需要手动回收吗"><span class="nav-number">6.</span> <span class="nav-text">我们需要手动回收吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含Handler参数的obtain-方法"><span class="nav-number">7.</span> <span class="nav-text">包含Handler参数的obtain()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包含Runnable参数的obtain-方法"><span class="nav-number">8.</span> <span class="nav-text">包含Runnable参数的obtain()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展方法"><span class="nav-number">9.</span> <span class="nav-text">扩展方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列化对象"><span class="nav-number">10.</span> <span class="nav-text">序列化对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置Message是异步传输还是同步传输"><span class="nav-number">11.</span> <span class="nav-text">设置Message是异步传输还是同步传输</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Keem Wang</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.5.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  
  

  

  

  

  

  

  

</body>
</html>
